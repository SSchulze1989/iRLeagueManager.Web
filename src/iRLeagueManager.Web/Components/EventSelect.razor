@implements IDisposable
@using System.Collections.Specialized
@using System.Globalization
@using System.Collections.ObjectModel
@using System.ComponentModel
@using iRLeagueManager.Web.ViewModels
@using System.Linq

<div @attributes=AdditionalAttributes class=@CssClass >
    <label class="input-group-text">Select Event</label>
    <select @bind=SelectedIndex class="form-select">
        @foreach((var @event, var index) in Events.Select((x, i) => (x, i)))
        {
            <option value="@(index)">@((index + 1).ToString("00")). @(@event.Date.ToString("dd.MM.yy")): @(@event.TrackName)@(@event.ConfigName == "-" ? "" : $" - {@event.ConfigName}")</option>
        }
    </select>
    <button class="btn btn-outline-secondary" type="button" @onclick=EventMovePrevious disabled=@(SelectedIndex == 0)><span class="oi oi-chevron-left"></span></button>
    <button class="btn btn-outline-secondary" type="button" @onclick=EventMoveNext disabled=@(SelectedIndex == Events.Count-1)><span class="oi oi-chevron-right"></span></button>
</div>

@code {
    [Parameter(CaptureUnmatchedValues=true)]
    public IReadOnlyDictionary<string, object>? AdditionalAttributes { get; set; }
    [CascadingParameter]
    public LeagueApiService ApiService { get; set; } = default!;

    private EventListViewModel eventList = default!;
    [CascadingParameter]
    public EventListViewModel EventList 
    {
        get => eventList;
        set
        {
            if (eventList != null)
            {
                eventList.EventList.CollectionChanged -= OnEventsCollectionChanged;
                eventList.PropertyChanged -= OnEventListPropertyChanged;
            }
            eventList = value;
            if (eventList != null)
            {
                eventList.EventList.CollectionChanged += OnEventsCollectionChanged;
                eventList.PropertyChanged += OnEventListPropertyChanged;
            }
        }
    }

    private ObservableCollection<EventViewModel> Events => EventList.EventList;

    [Parameter]
    public EventViewModel? Selected 
    { 
        get => eventList?.Selected;
        set
        {
            if (eventList != null && value != eventList.Selected)
            {
                eventList.Selected = value;
                _ = SelectedChanged.InvokeAsync(value);
            }
        }
    }

    [Parameter]
    public EventCallback<EventViewModel?> SelectedChanged { get; set; }

    private const string BaseClass = "input-group container px-0 mb-2 mx-0";
    private string CssClass
    {
        get
        {
            if (AdditionalAttributes == null || AdditionalAttributes.TryGetValue("class", out var @class) == false)
            {
                return BaseClass;
            }
            var classAttributeValue = Convert.ToString(@class, CultureInfo.InvariantCulture);
            return $"{BaseClass} {classAttributeValue}";
        }
    }

    private int selectedIndex = 0;
    public int SelectedIndex
    {
        get => selectedIndex;
        set
        {
            if (selectedIndex != value)
            {
                selectedIndex = value;
                _ =OnSelectionChanged();
            }
        }
    }

    protected override void OnParametersSet()
    {
        if (Selected != null && Events.IndexOf(Selected) != selectedIndex)
        {
            SelectedIndex = Events.IndexOf(Selected);
        }
    }

    private void OnEventsCollectionChanged(object? sender, NotifyCollectionChangedEventArgs e)
    {
        // Update selectedIndex
        if (Selected != null && Events.IndexOf(Selected) != selectedIndex)
        {
            SelectedIndex = Events.IndexOf(Selected);
        }
        InvokeAsync(StateHasChanged);
    }

    private void OnEventListPropertyChanged(object? sender, PropertyChangedEventArgs e)
    {
        switch (e?.PropertyName)
        {
            case nameof(EventListViewModel.Selected):
                OnEventsChanged();
                break;
        }
    }

    private void OnEventsChanged()
    {
        // Update selectedIndex
        if (Selected != null && Events.IndexOf(Selected) != selectedIndex)
        {
            SelectedIndex = Events.IndexOf(Selected);
        }
        InvokeAsync(StateHasChanged);
    }

    private async Task OnSelectionChanged()
    {
        Selected = Events.ElementAtOrDefault(SelectedIndex) ?? Selected;
        await Task.FromResult(true);
    }

    private void EventMoveNext()
    {
        if (SelectedIndex < Events.Count-1)
        {
            SelectedIndex++;
        }
    }

    private void EventMovePrevious()
    {
        if (SelectedIndex > 0)
        {
            SelectedIndex--;
        }
    }

    public void Dispose()
    {
        if (eventList != null)
        {
            eventList.EventList.CollectionChanged -= OnEventsCollectionChanged;
            eventList.PropertyChanged -= OnEventListPropertyChanged;
        }
    }
}
