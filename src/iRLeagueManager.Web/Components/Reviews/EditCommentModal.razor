@using iRLeagueApiCore.Common.Enums
@using iRLeagueApiCore.Common.Models.Members
@using iRLeagueApiCore.Common.Models.Reviews
@using iRLeagueManager.Web.ViewModels
@inherits MvvmComponentBase
@inject ReviewCommentViewModel Comment

<EditForm Model=Comment OnValidSubmit=Submit>
    <InputGroup Label=Text>
        <InputTextArea class="form-control" @bind-Value=Comment.Text/>
    </InputGroup>
    <CancelSubmitButtons ModelState=Comment SubmitText="Save" OnCancel=Cancel/>
</EditForm>

@code {
    private CancellationTokenSource cts = new();

    [CascadingParameter]
    public BlazoredModalInstance? ModalInstance { get; set; }
    [Parameter]
    public IEnumerable<MemberInfoModel> InvolvedMembers { get; set; } = Array.Empty<MemberInfoModel>();
    //[Parameter]
    //public ReviewViewModel Review { get; set; } = default!;

    [Parameter]
    public ReviewCommentModel Model { get; set; } = default!;

    [Parameter]
    public Func<ReviewCommentViewModel, CancellationToken, Task<bool>>? OnSubmit { get; set; }

    protected override void OnParametersSet()
    {
        _ = Model ?? throw new InvalidOperationException($"Parameter {nameof(Model)} must have a value");
    }

    protected override void OnAfterRender(bool firstRender)
    {
        if (firstRender == false)
        {
            return;
        }
        Comment.SetModel(Model);
    }

    private async Task Submit()
    {
        //var success = await Review.SaveChangesAsync(cts.Token);
        bool success = true;
        if (OnSubmit != null)
        {
            success |= await OnSubmit.Invoke(Comment, cts.Token);
        }
        if (success && ModalInstance != null)
        {
            var result = ModalResult.Ok(Comment.GetModel());
            await ModalInstance.CloseAsync(result);
        }
    }

    private async Task Cancel()
    {
        if (ModalInstance != null)
        {
            await ModalInstance.CancelAsync();   
        }
    }

    protected override void Dispose(bool disposing)
    {
        if (disposing == false)
        {
            cts.Cancel();
            cts.Dispose();
        }
        base.Dispose(disposing);
    }
}
