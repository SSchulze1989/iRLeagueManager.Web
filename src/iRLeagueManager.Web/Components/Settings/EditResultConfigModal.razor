@inherits EditModalBase<ResultConfigViewModel, ResultConfigModel>
@using iRLeagueApiCore.Common.Enums
@using iRLeagueApiCore.Common.Models
@using iRLeagueManager.Web.ViewModels
@inject IJSRuntime JsRuntime

<CascadingValue Value="@Bind(Vm, x => x.LeagueMembers).AsEnumerable()">
<EditForm Model=Vm OnValidSubmit=Submit>
    <StatusResultValidator @ref=ResultValidator />
    <div class="accordion mb-3" id="resultConfigSections">
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapseGeneralSettings" aria-expanded="true" aria-controls="collapseGeneralSettings">
                    General Settings
                </button>
            </h2>
            <div class="accordion-collapse collapse show input-group-list m-1" id="collapseGeneralSettings">
                <InputGroup Label="Name" ValidationFor="() => Vm.Name">
                    <InputText class="form-control" id="input-name" placeholder="Name..." aria-label="input-name" @bind-Value=Vm.Name data-bs-toggle="tooltip" title="Identifying name of the result config" />
                </InputGroup>
                <InputGroup Label="Type">
                    <InputSelect class="form-select" id="input-type" placeholder="Type..." aria-label="input-type" @bind-Value=Vm.ResultKind data-bs-toggle="tooltip" title="Type of the race that will be scored: select from Member or Team race">
                        <option value=@ResultKind.Member>Member</option>
                        <option value=@ResultKind.Team>Team</option>
                    </InputSelect>
                </InputGroup>
                <InputGroup Label="Source">
                    <InputSelect class="form-select" id="input-source" placeholder="Source..." aria-label="input-source" @bind-Value=Vm.SourceResultConfigId data-bs-toggle="tooltip" 
                        title="<div class='text-start'>Data source for the results: 
                            <ul>
                                <li>select 'Raw' to use uploaded result</li>
                                <li>other result config to re-use a calculated result set</li>
                            </ul></div>">
                        <option value="0">Raw</option>
                        @foreach(var config in @Bind(Vm, x => x.AvailableResultConfigs).Where(CanSelectAsSourceConfig))
                        {
                            <option value=@config.ResultConfigId>
                                @*--> "[ChampionshipName - ]ConfigName"*@
                                @(string.IsNullOrEmpty(config.ChampionshipName) ? "" : $"{config.ChampionshipName} - ")@config.Name
                            </option>
                        }
                    </InputSelect>
                </InputGroup>
                @if (Vm.ResultKind == ResultKind.Team)
                {
                    <InputGroup Label="Results per Team">
                        <InputNumber class="form-control" id="input-results-per-team" aria-label="input-results-per-team" @bind-Value=Vm.ResultsPerTeam data-bs-toggle="tooltip" title="Number of member results that are counted in a team race. E.g: 2 will take the top 2 results from all team members in this race" />
                    </InputGroup>
                }
            </div>
        </div>

        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapseFilters" aria-expanded="true" aria-controls="collapseFilters">
                    Filters
                </button>
            </h2>
            <div class="accordion-collapse collapse show input-group-list m-1" id="collapseFilters">
                <InputGroup Label="Points Filter">
                    <button class="form-control" type="button" @onclick=PointsFilterClick data-bs-toggle="tooltip" title="Filter rows that can score points. Only rows that fulfill all filter requirements will be given points. Rows are still displayed in the output result set">
                        @if (Vm.FiltersForPoints.Count == 0)
                        {
                            <span class="text-secondary"><em>Configure</em></span>
                        }
                        else
                        {
                            <span class="text-secondary">@Vm.FiltersForPoints.Count filters applied</span>
                        }
                    </button>
                </InputGroup>
                <InputGroup Label="Result Filter">
                    <button class="form-control" type="button" @onclick=ResultFilterClick data-bs-toggle="tooltip" title="Filter rows and remove them from the result. Only rows that fulfill all filter requirements will be visible int the output result set">
                        @if (Vm.FiltersForResult.Count == 0)
                        {
                            <span class="text-secondary"><em>Configure</em></span>
                        }
                        else
                        {
                            <span class="text-secondary">@Vm.FiltersForResult.Count filters applied</span>
                        }
                    </button>
                </InputGroup>
            </div>
        </div>

        <div class="accordion-item">
            <h2 class="accordion-header" data-bs-toggle="tooltip" data-bs-trigger="hover" title="<p>Scoring options for individual sessions.</p><p>Create one Scoring for each race type session in the event (1 is default - multiple for heat events)</p>">
                <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSessionScorings" aria-expanded="true" aria-controls="collapseSessionScorings">
                    Session Scorings
                </button>
            </h2>
            <div class="accordion-collapse collapse show m-1" id="collapseSessionScorings">
                @foreach(var scoring in @Bind(Vm, x => x.Scorings).Where(x => x.IsCombinedResult == false))
                {
                    <div class="input-group-list mb-3">
                        <div class="input-group">
                            <InputText class="form-control" id="scoring-name" aria-label="scoring-name" placeholder="Name..." @bind-Value=scoring.Name
                                data-bs-toggle="tooltip" title="Name of the session scoring to be displayed on results"/>
                            <button class="btn btn-outline-danger" type="button" @onclick="@(() => Vm.RemoveScoring(scoring))"><span class="oi oi-trash"/></button>
                        </div>
                        <EditScoring Scoring=scoring />
                    </div>
                }
                <div class="mt-3">
                    <button class="btn btn-outline-secondary" type="button" @onclick="@(() => Vm.AddScoring())">Add Scoring</button>
                </div>
            </div>
        </div>

        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapseCombined" aria-expanded="true" aria-controls="collapseCombined">
                    Combined Result
                </button>
            </h2>
            <div class="accordion-collapse collapse show input-group-list m-1" id="collapseCombined">
                <div class="input-group" disabled>
                    <div class="input-group-text">
                        <InputCheckbox class="form-check-input mt-0" @bind-Value=Vm.CalculateCombinedResult/>
                    </div>
                    <label class="form-control" data-bs-toggle="tooltip" title="Combine results from heat sessions into a single event result">Get Combined Result</label>
                </div>
                @if (Vm.CalculateCombinedResult)
                {
                    var combinedScoring = Vm.Scorings.First(x => x.IsCombinedResult);
                    <div class="input-group" disabled>
                        <div class="input-group-text">
                            <InputCheckbox class="form-check-input mt-0" @bind-Value=combinedScoring.CalcPoints/>
                        </div>
                        <label class="form-control" data-bs-toggle="tooltip" title="Run points calculation for the combined result">Calculate Points</label>
                    </div>
                    <EditScoring Scoring=combinedScoring />
                }
            </div>
        </div>
    </div>
    <FormValidationMessage TValue=string Message=@ResultValidator?.ErrorMessage />
    <CancelSubmitButtons ModelState=Vm SubmitText="Save" OnCancel=Cancel/>
</EditForm>
</CascadingValue>

@code {
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);
        if (firstRender == false)
        {
            return;
        }
        await Vm.LoadAvailableResultConfigs(Cts.Token);
        await Vm.LoadLeagueMembers(Cts.Token);
    }

    private async Task PointsFilterClick()
    {
        var parameters = new ModalParameters<EditResultFilterModal>()
            .Add(x => x.Model, Vm.GetModel().FiltersForPoints)
            .Add(x => x.LeagueMembers, Vm.LeagueMembers);
        var options = new ModalOptions()
        {
            DisableBackgroundCancel = true,
        };
        var result = await ModalService.Show<EditResultFilterModal>("Edit Points Filter", parameters, options).Result;
        if (result.Confirmed && result.Data is IEnumerable<ResultFilterModel> model)
        {
            Vm.GetModel().FiltersForPoints = model.ToList();
            Vm.SetModel(Vm.GetModel());
        }
    }

    private async Task ResultFilterClick()
    {
        var parameters = new ModalParameters<EditResultFilterModal>()
            .Add(x => x.Model, Vm.GetModel().FiltersForResult)
            .Add(x => x.LeagueMembers, Vm.LeagueMembers);
        var options = new ModalOptions()
        {
            DisableBackgroundCancel = true,
        };
        var result = await ModalService.Show<EditResultFilterModal>("Edit Result Filter", parameters, options).Result;
        if (result.Confirmed && result.Data is IEnumerable<ResultFilterModel> model)
        {
            Vm.GetModel().FiltersForResult = model.ToList();
            Vm.SetModel(Vm.GetModel());
        }
    }

    private bool CanSelectAsSourceConfig(ResultConfigModel model)
    {
        bool isNotSelf = model.ResultConfigId != Vm.ResultConfigId;
        bool isNotDepending = model.SourceResultConfig?.ResultConfigId != Vm.ResultConfigId;
        bool isNotOnSameChampionship = model.ChampSeasonId != Vm.ChampSeasonId;
        return isNotSelf && isNotDepending && isNotOnSameChampionship;
    }
}
