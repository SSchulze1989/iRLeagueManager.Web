@namespace iRLeagueManager.Web.Pages
@page "/{LeagueName}/Results/Events/{EventId:long}/Edit"
@using System.Reflection
@using System.Linq.Expressions
@using iRLeagueApiCore.Common.Models
@inherits LeagueComponentBase
@inject EditResultViewModel Result
@inject IDialogService DialogService
@attribute [Authorize]

<PageTitle>
    Edit Result - @LeagueName
</PageTitle>

<MudContainer MaxWidth="MaxWidth.ExtraLarge">
    <LoadingHeader Loading="Result.Loading">
        <HeaderText>
            <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="0" Style="margin-left: -0.5em">
                <MudIconButton Icon="@Icons.Material.Filled.ArrowBack" Href="@($"/{LeagueName}/Results/Events/{EventId}")" />
                <MudText Typo="Typo.h5">Edit Result</MudText>
            </MudStack>
        </HeaderText>
    </LoadingHeader>

    <AuthorizeView Roles="@GetRoleString(LeagueRoles.Admin, LeagueRoles.Organizer)">
        <Authorized>
            <MudAlert Severity="Severity.Warning">
                Editing the raw results is permanent. Please take care when editing your leagues results.
            </MudAlert>

            @foreach (var sessionResult in Result.SessionResults.AsEnumerable().Reverse())
            {
                var sessionName = Event?.Sessions.FirstOrDefault(x => x.SessionId == sessionResult.SessionId)?.Name;
                <MudElement HtmlTag="div" Class="mt-3">
                    <MudText Typo="Typo.h6">@sessionName</MudText>
                    <EditResultTable SessionResult="sessionResult" Members="Result.Members" Teams="Result.Teams"/>
                    @if (sessionResult.HasChanges)
                    {
                        <MudStack Row="true" Spacing="2" Justify="Justify.FlexEnd" Class="m-2">
                            <MudButton Color="Color.Primary"
                                       Variant="Variant.Filled"
                                       Size="Size.Large"
                                       OnClick="@(async () => await SaveSessionResult(sessionResult))">
                                Save
                            </MudButton>
                            <MudButton Color="Color.Secondary"
                                       Variant="Variant.Outlined"
                                       Size="Size.Large"
                                       OnClick="@(() => sessionResult.Reset())">
                                Reset
                            </MudButton>
                        </MudStack>
                    }
                </MudElement>
            }
        </Authorized>
        <NotAuthorized>
            <MudAlert Severity="Severity.Error">Not allowed</MudAlert>
        </NotAuthorized>
    </AuthorizeView>
</MudContainer>

@code {
    private bool hasSavedChanges = false;

    protected override void OnInitialized()
    {
        base.OnInitialized();
        Result.HasChanged += OnResultChanged;
        RegisterLocationChangingHandler();
    }

    private void OnResultChanged(object? sender, EventArgs e)
    {
        InvokeAsync(StateHasChanged);
    }

    protected override async Task OnEventChangedAsync(EventViewModel? @event)
    {
        if (@event is null)
        {
            Result.SetModel(new());
            return;
        }
        await Result.Load(@event.EventId);
    }

    protected override void Dispose(bool disposing)
    {
        if (disposing)
        {
            Result.HasChanged -= OnResultChanged;
        }
        base.Dispose(disposing);
    }

    protected override async ValueTask OnLocationChanging(LocationChangingContext context)
    {
        // Do nothing when viewmodel has no changes or navigation on same page
        var staysOnPage = context.TargetLocation.Contains($"{LeagueName}/Results/Events/{EventId}/Edit");
        var allowNavigation = staysOnPage;
        if (allowNavigation)
        {
            await base.OnLocationChanging(context);
            return;
        }

        // If viewmodel has changes: Cancel navigation and display message
        var sessionResultsHaveChanges = Result.SessionResults.Any(x => x.HasChanges);
        if (sessionResultsHaveChanges)
        {
            var cancelNavigation = await CancelNavigationOnUnsavedChanges();
            if (cancelNavigation)
            {
                context.PreventNavigation();
                return;
            }
        }

        // If changes have been saved: ask for calculation of results
        if (hasSavedChanges)
        {
            await AskCalculateResults();
        }
    }

    private async Task AskCalculateResults()
    {
        var dialogParameters = new DialogParameters<ConfirmDialog>()
        {
            { x => x.ButtonTypes, ButtonTypes.YesNo },
        };
        var confirmDialog = await DialogService.Show<ConfirmDialog>("Calculate results?", dialogParameters).Result;
        if (confirmDialog?.Canceled != false)
        {
            return;
        }
        await Result.CalculateResults(CancellationToken);
    }

    private async Task<bool> CancelNavigationOnUnsavedChanges()
    {
        var dialogParameters = new DialogParameters<ConfirmDialog>()
        {
            { x => x.Text, "You have unsaved changes. Are you sure you want to leave this page? Unsaved changes will be lost." },
            { x => x.ButtonTypes, ButtonTypes.YesNo },
        };
        var confirmDialog = await DialogService.Show<ConfirmDialog>("Unsaved changes", dialogParameters).Result;
        if (confirmDialog?.Canceled == false)
        {
            // User confirmed navigation: Reset changes and navigate to target location
            Result.SessionResults.ForEach(x => x.Reset());
            return false; // allow navigation
        }
        return true; // cancel navigation
    }

    private async Task SaveSessionResult(RawSessionResultViewModel sessionResult)
    {
        if (Event is null)
        {
            return;
        }
        var status = await sessionResult.SaveAsync(Event.EventId, CancellationToken);
        if (!status.IsSuccess)
        {
            return;
        }
        hasSavedChanges = true;
    }
}
